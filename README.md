# Virtual Memory Manager

This project consists of writing a program that translates logical to physical addresses for a virtual
address space of size 65,536 bytes. Your program will read from a file containing logical addresses
and, using a TLB and a page table, will translate each logical address to its corresponding physical
address and output the value of the byte stored at the translated physical address. 

#### The learning goal is to use simulation to understand the steps involved in translating logical to physical addresses.

## Table of Contents
1. [Introduction](#1-introduction)
2. [Implementation](#-implementation)
3. [How to Run](#-how-to-run)
4. [Notes](#-notes)
5. [Conclusion](#-conclusion)



## üìò Introduction

Virtual memory is a foundational concept in modern operating systems. It enables each program to act as though it has access to its own large, continuous block of memory, even though the actual physical memory (RAM) might be much smaller and shared among many processes.

### üß† Why It Exists
The virtual memory manager (VMM) exists to:
- Simplify memory management for programs.
- Protect processes from accessing each other's memory.
- Make efficient use of RAM through demand paging.

### üß± How It Works ‚Äì Structure of the VMM

A **logical address** generated by the CPU consists of two parts:
- **Page Number**: Specifies which virtual page to access.
- **Offset**: The specific byte within that page.

These pages are stored in **frames**, which are fixed-size blocks of physical memory. The mapping from virtual pages to physical frames is handled by:

- **Page Table**: A table storing the frame number for each page. If a page isn't in memory, it's loaded from secondary storage (like the backing store).
- **Translation Lookaside Buffer (TLB)**: A small, fast cache that stores recent page-to-frame mappings to speed up translation.

When a page is accessed:
1. The TLB is checked for a quick match (TLB hit).
2. If not in the TLB (TLB miss), the page table is checked.
3. If the page is not in physical memory, a **page fault** occurs:
   - The page is loaded from the backing store into an available frame.
   - The page table and TLB are updated accordingly.

This layered approach efficiently manages address translation while maintaining performance and reliability.

---

## üõ†Ô∏è Implementation

- The system reads logical addresses from `addresses.txt`.
- It separates the **page number** and **offset** from each address.
- It checks if the page is in the TLB:
  - If **yes** ‚Üí TLB hit ‚Üí Use frame number from TLB.
  - If **no** ‚Üí Check the page table.
    - If not found in page table ‚Üí **Page fault** occurs:
      - Load page from `BACKING_STORE.bin` into physical memory.
      - Update the page table and TLB.
- The program then forms the final **physical address** using frame number and offset.
- Outputs the physical address and the byte value at that address.

---

## üöÄ How to Run

### Requirements:
- C compiler (e.g., `gcc`)
- Files: `vm.c`, `addresses.txt`, `BACKING_STORE.bin`

### Compilation:
```bash
make vm
make clean
```

## üìé Notes
Page size: 256 bytes

TLB size: 16 entries (FIFO replacement)

Page table size: 256 entries

Physical memory: 65,536 bytes (256 frames √ó 256 bytes per frame)

## Conclusion
This project offers hands-on experience with the components of a virtual memory manager. By implementing address translation through a TLB and page table, simulating page faults, and loading data on demand, we gain a deeper understanding of how operating systems abstract and manage memory.

It shows how logical addresses relate to physical memory through structured layers and how real-world systems optimize these translations for speed and efficiency using caching and paging techniques.
